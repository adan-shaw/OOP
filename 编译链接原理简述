< 前言: 安装man 手册 >
centos:
yum install man-pages

debian:
apt-get install manpages-de manpages-de-dev manpages-dev glibc-doc manpages-posix-dev manpages-posix



*******************************************************************
< x0.gcc g++ 的差别 >
网文:  https://blog.csdn.net/bit_clearoff/article/details/53965514

*总结*:
    C++ 本质上, 只是C++ 对C 语言的语法翻译! 
    GCC 本质上就是C 语言编译器, glibc 库本质上就是C 语言'运行时库', kernel 本质上就是纯C 项目.
    glibc 需要与kernel 互相呼应, 但是编译器版本可以随意更换.
    至于C++, 只是一种语法翻译!
    将C++ 语法, 翻译出C 语言的具体实现.
    编程者不需要理会底层glibc 和kernel 是怎样实现的, 只要翻译出跟C++ 功能类似的API 即可.
    内核和glibc 讲求效率, 不会特别对待C++ 的.
    屏蔽C++ 语法, 实现高效kernel 和glibc 运行时库, 是一个聪明的做法.


*细节*:
>1.g++ 编译.c/.cpp 文件时, 生成的预编译, 编译, 汇编, 链接, 四个过程的文件.i, .s, .o, .exe 都是一样的.
   证明g++ 在遇到.c 语言的时候, 还是调用gcc 的接口, g++ 兼容c 语言.

>2.gcc 编译.cpp 文件时, 会发生分歧:
   预编译: gcc 不能处理c++ 特有的预编译语句
   编译  : gcc 不能编译出c++ 库函数的汇编码
   汇编  : 将汇编码翻译成.o 文件, 这一步还是没啥区别的, 反正这是一个固定操作.
   链接  : gcc 不能链接g++ 的标准库, 也不能链接一些由c++ 编写的第三方库
          (就算连上了也会报错的)
   证明: gcc 不能翻译出c++ 语法!!

所以: 用g++ 兼容性强一些, 但是也要坚持写纯C 码, 然后弱c++ 语法还是很不错的





< x1.gcc 编译原理 >
[[ 你可以用一个hello world 程序, 
   跟着下面的1,2,3,4 个步骤去编译一个程序, 来查看真实的编译过程 ]]
(.i)1.预编译 -E  [处理宏定义和include, 去除注释, 不会对语法进行检查. ]

(.s)2.编译   -S  [检查语法, 生成汇编代码]

(.o)3.汇编   -c  [生成目标代码]

(  )4.链接   -o  [链接过程. 生成可执行代码. 
                 链接分为两种, 一种是静态链接, 另外一种是动态链接. ]
                *[使用静态链接的好处是, 依赖的动态链接库较少, 
                  对动态链接库的版本不会很敏感, 具有较好的兼容性; 
                  缺点是生成的程序比较大. ]
                *[使用动态链接的好处是, 生成的程序比较小, 占用较少的内存. ]


只要'生成的.o 文件' 完整且正确 (不能缺少某个.o), 然后就可以进行最后一步->(链接).
最后一步<4.链接>, 链接可能找不到.o 文件or -l 编译选项库等, 可能会发生错误. 

生成可执行文件后:
  无论什么后缀都可以直接运行, linux 不认后缀, 直接认封装的, 
  链接之后就是可执行二进制封装了.





< x2.gcc/ld 链接原理 >
  gcc 实际上只是一个c 语言编译器, ld 才是真正的链接器.
  gcc 实际也是调用ld 的功能做链接, 这个概念让人混淆, 让人觉得gcc 是一个链接器, 实际这是错误的!


  ld 是一个将编译好的代码, 链接起来的工具.
  编译好的代码, 为什么需要链接??
  因为:
    实际编译好之后, 所有的函数, 都只是一根函数指针而已.
    函数体API 哪里去了??
    如果是'.a 静态库': 
      ld 链接器在链接的时候, 会将函数体整个拷贝一份出来, 插入到程序中.
      因此你可以看到, 使用ld 链接之后, .exe 文件远比.o 编译文件'大得多'.

      [ 微软的静态库与gcc 静态库有些不一样, 由于微软是商业系统, 对自家的静态库管理比较简单,
        微软提供: #program comment(lib,"") 来包含.a 静态库, 但是gcc 并没有相关的实现.]

      总体来说, 静态库需要直接用-l 'LDFLAGS链接选项'指明静态库的路径!!
      -lpthread 实际上, 就是链接静态库'libpthread.a', 在glibc 的实现中, 你可以找到:
        -lpthread = /lib/x86_64-linux-gnu/libpthread.so.0
        -lm       = /lib/x86_64-linux-gnu/libm.so.6
        (去掉lib 前缀和.so .a 后缀 + 版本号, remember??)


    另外: 
      静态库不需要描述装载过程, .a 静态库, 实际就是一个'.o 文件的集合', 
      编译器可以自己找出对应的'.o 文件', 这很简单.
      动态库需要描述装载过程, 因为动态库是用来'共享'函数api 使用的, 
      '.so 共享库', 实际与.exe 可执行程序, 没有区别.
      编译器根本不知道'.so 共享库'内部的运行机制.(所以函数调出, 有1-5% 的性能损耗)
      所以, '.so 共享库'需要用'函数指针'来描述'装载的是哪个函数api', 有多少参数, 返回值.(描述装载过程)
      当然:
        一个已经tarball install 的库, 如-lpthread 库:
          它会在头文件<pthread.h>中, 声明所有的使用api(函数名称, 形参, 返回值等声明).

          而'.so 共享库'函数体, 是怎样工作的(以pthread 为例)？
          你只要添加-lpthread, 那么链接之后的程序, 一旦运行该程序, 该程序就会自动帮你申请装载libpthread.so.0,
              '.so 共享库'只要根据函数名, 就可以找到函数的位置, 但是形参和返回值, 是不知道的.
              如果你输入的实参出错, 又或者是返回值出错, 编译器是不管的, 
              只能靠<pthread.h> 头文件保证形参和返回值的准确性！！
          但是[根据函数名, 就可以找到函数的位置], 
          所以你 链接装载 '.so 共享库'之后, 就可以根据'函数名'访问函数体了.



     为什么libpthread.so.0 不用描述装载过程, 而第三方.so 库 libmysql.so 需要描述装载过程？
     tarball install 之后又不需要再描述装载过程?? why ??




    按照你的意思, 那么只要用到'链接库', 
    编译出'.o 文件'之后, 如果不进行ld 链接, 那么'.o 文件'运行, 将会找不到.a / .so 库的函数api??
    的确是这样！！(如果是第三方.a / .so 库, 且没有tarball install 的话)
    现代系统有一个自己的'ld 链接库'装载机制, 很多链接库, 是系统运行的必须环境, 如libc.so.6
    那么: 
      系统本身已经装载了这些库了, 所以你在编译出'.o 文件'之后, 不用链接, 也可以直接运行.
      但是原则上, 如果是一个未tarball install 的'第三方链接库', 你还是会找不到'.a / .so 库的函数api'的.
      编译通过, 运行出错, 提示: undefined reference to 'func_xxx'
      这种报错, 就是找不到'第三方库的函数api' 的情况(动态库/静态库 都一样).


    如果是'.so 动态库':
      你需要在程序实现的过程中, 描述??????????????/待解





< x2.gcc 调试工具 >
*1.GCC 除错的首选工具是< GNU 除错器 >, 即gdb. 

*2.其他特殊用途的除错工具是 Valgrind, 用以发现内存漏失 (Memory leak). 

*3.GNU 测量器 (gprof) 可以得知程序中某些函式花费多少时间, 以及其呼叫频率; 
   此功能需要使用者在编译时选定测量〈profiling〉选项, 即编译选项-pg





< x3.gcc 编译选项 >
优化选项: 
  用GCC编译C/C++代码时, 它会试着用最少的时间完成编译并且编译后的代码易于调试. 
  易于调试意味着编译后的代码与源代码有同样的执行顺序, 编译后的代码没有经过优化. 
  
  有很多的选项可以告诉GCC, 在耗费更多编译时间和牺牲易调试性的基础上,
  产生更小更快的可执行文件. 
  这些选项中最典型的就是-O和-O2. 
  -O选项告诉gcc对源代码进行基本优化. 
  -O2选项告诉GCC产生尽可能小的和尽可能快的代码. 
  还有一些很特殊的选项可以通过man gcc察看. 

 -O, 对程序进行优化编译、链接.
     采用这个选项, 整个源代码会在编译、链接过程中进行优化处理, 
     这样产生的可执行文件的执行效率可以提高, 
     但是, 编译、链接的速度就相应地要慢一些. 
 -O2,比-O更好的优化编译、链接, 当然整个编译、链接过程会更慢. 





调试和剖析选项: 
  GCC支持数种调试剖析选项. 在这些选项中最常用的是-g和-pg.
  -g选项 告诉gcc产生能被GNU调试器（如gdb)使用的调试信息, 以便调试用户的程序.
         不能与-o 优化选项一同使用
  -pg选项 告诉gcc在用户的程序中加入额外的代码, 执行时, 
          产生gprof用的剖析信息以显示程序的耗时情况. 
          <但必须指定为GNU 源码才能使用-pg>


 -g, 产生符号调试工具(GNU的gdb)所必要的符号资讯, 
     要想对源代码进行调试, 我们就必须加入这个选项. 
-pg, 性能策略工具, 有了这个, 你就不需要自己做<太多不需要>的性能测试统计了, 
     gcc 帮你完成基础的性能测试. 




//***************************************************************


预编译, 编译, 汇编, 链接, 四个过程详细分析, 其它编译选项再说吧. 

//测试源码
#include<stdio.h>
int main(void){
  printf("hello world\n");
  return 0;
}



1.预编译过程
这个过程处理宏定义和include, 去除注释, 不会对语法进行检查. 
可以看到预编译后, 代码从6行扩展到了910行. 

gcc -E a.c -o a.i
cat a.c|wc -l
5
cat a.i|wc -l
910


2.编译过程
这个阶段, 检查语法, 生成汇编代码. 

gcc -S a.i -o a.s
cat a.s|wc-l
59


3.汇编过程
这个阶段, 生成目标代码. 此过程生成ELF格式的目标代码. 

gcc -c a.s -o a.o
file a.o
a.o:ELF64-bitLSBrelocatable,AMDx86-64,version1(SYSV),notstripped


4.链接过程
链接过程. 生成可执行代码. 链接分为两种, 一种是静态链接, 另外一种是动态链接. 
使用静态链接的好处是, 依赖的动态链接库较少, 
对动态链接库的版本不会很敏感, 具有较好的兼容性; 
缺点是生成的程序比较大. 
使用动态链接的好处是, 生成的程序比较小, 占用较少的内存. 

gcc a.o -o a

程序运行: 
./a
hello

