# 方法1:
# 直接让编译器自己找依赖关系, 自己只指出源文件所在, 不管编译过程.
#
#
# 但是, 这个方法很简单, 但有缺点:
# 当你需要链接一个'第三方库'的时候, 例如cjson,
# 如果csjon 已经tarball install, 则安装后:
#   libcjson.a 或者libcjson.so 库, 就会添加到/usr/local/lib 中,
#   cjson.h 就会添加到/usr/local/include 中,
#   此时编译器当然可以找到<cjson.h> 头文件, 还有-lcjson 编译选项.
#   (注意: 根据-l 搜索法, lib 前缀去掉, .a / .so 后缀去掉, 这个原则不变)
#
# 但如果你不能对cjson 进行tarball 时, 怎样使用一个'非安装'的第三方库??
# (如果是处于安全考虑, 你不能make install 的话, 那么软件实现的时候, 就需要你手动指明.h 还有.a / .so 库的路径了)
#
#
######################################################################################
# 这两种做法有点问题, 你参考链接原理更实际, 关于链接时, 如何找到静态, 动态链接库
# 其它问题不大!!
# 你有两种做法:
# *1. 在/usr/local/lib 中, 添加一个link to ./libcjson.a, 链接到libcjson.a 库文件中.
#     (libcjson.so 同理, 一样的操作)
#     然后在/usr/local/include 同样添加一个link to ./cjson.h, 链接到libcjson.h 头文件中.
#     最后, 如果你使用的是.so 共享库, 还需要:
#       用ldconfig 更新一下'系统已经装载的.so 文件list', 让系统将新增的.so 库文件'挂载起来'!
#       如果.so 库文件没有'挂载起来', 可能出现-c 编译通过, 但是-o 链接失败的情况.
#     但是如果是添加.a 库文件, 即表示'静态编译'!!
#
#     由于头文件可能有多个, 你可以直接link to <cjson/*> cjson.h 所在的父目录中, 
#     以后包含就直接用: include <cjson/csjon.h>, 多一个文件夹映射.
# 以上, 是一种方法, 但比较蹩脚, [实际上, 虽然不安装程序, 但是已经将'第三方库'装载到ldconfig 中了.]
#
#
# *2. 让编译器自己搜索库文件, 头文件. 再添加编译!!
#     编译器-I, 指定搜索'头文件目录'的路径,
#     编译器-L, 指定搜索'库文件目录'的路径,
#     找到路径之后, 再利用-i 包含头文件, 再利用-l 包含库文件. (这两个选项, 都必须在-I -L 路径指认完成后使用.)
#     这样就完成一个'自由的'第三方[库 + 头文件]指认编译过程了.
#     你也不需要make install 第三方库.
# 这种方法, 不需要更新ldconfig, 也就是'不需要更新'系统的.so 库文件装载情况, 
# 只当软件运行的时候, 才装载'第三方库', 运行结束, 就会释放'第三方库', 
# 因为只有它本身一个用户, 共享库没了使用者, 就会被系统释放.
######################################################################################
#
#
#
# 但是即便这样, 哪一个.cpp 源文件, 需要使用第三方库, 哪一个.cpp 源文件, 不需要用到第三方库,
# 在某些重叠的场合, 你需要分开指认:
#   分开指认头文件, 才能编译出正确的.o 文件,
#   分开指认库文件, 才能链接出正确的.exe 可执行文件,
# 但是一般情况下, 你仍然可以用方法1, 只指出源文件所在, 其它的依赖关系, 全部使用'静默规则', 让编译器自己编译.
# ps: 
#   静默规则是: test.h test.cpp test.o 三个文件名, 必须相同, 只有后缀不同的情况下, 才能使用'静默规则'!!
#
#
#
# *原理解剖*:
#   问: 为什么-c 编译的时候, 只需要指认.h 文件即可, 函数体的执行代码去哪里了??
#   答: 由于现代系统, 都是利用.so 链接库来节省内存, 那么
#       如果'第三方库'的存储载体是.so 共享库, 
#       那么.h 文件表明的, 实际只是函数指针, 
#       '函数体'存放在系统'已经装载的.so 共享库'中, 或者程序给出的.so 共享库文件中,
#
#       如果'第三方库'的存储载体是.a 静态库, 那么'函数体'存放在该.a 静态库中. 
#       .h 文件里面的, 同样也是函数指针, 但是运行的时候, 不能缺少.a 库文件!!
#
#       如果你需要'静态编译', 或者说: '静态链接'更准确, 
#       编译器在链接的时候, 就会将'函数指针' 全部替换为'函数实体'.
#   这就是编译链接原理的本质!!
#
#   问: gcc 编译器的搜索路径顺序, 优先级是(以debian 为例):
#   答: /usr/local/include/*
#       /usr/lib/gcc/x86_64-linux-gnu/6/include/*
#       /usr/include/x86_64-linux-gnu/include/*
#       /usr/include/*
