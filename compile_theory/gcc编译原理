< 前言: 安装man 手册 >
centos:
yum install man-pages

debian:
apt-get install manpages-de manpages-de-dev manpages-dev glibc-doc manpages-posix-dev manpages-posix



*******************************************************************
< x0.gcc g++ 的差别 >
网文:  https://blog.csdn.net/bit_clearoff/article/details/53965514

*总结*:
    C++ 本质上, 只是C++ 对C 语言的语法翻译! 
    GCC 本质上就是C 语言编译器, glibc 库本质上就是C 语言'运行时库', kernel 本质上就是纯C 项目.
    glibc 需要与kernel 互相呼应, 但是编译器版本可以随意更换.
    至于C++, 只是一种语法翻译!
    将C++ 语法, 翻译出C 语言的具体实现.
    编程者不需要理会底层glibc 和kernel 是怎样实现的, 只要翻译出跟C++ 功能类似的API 即可.
    内核和'glibc运行时库' 讲求的是效率, 不会特别对待C++ 的, 不会为C++ 重新写一个编译器!!
    集成C 语言编译器, 翻译C++ 语法, 实现高效kernel 和glibc 运行时库, 是一个聪明的做法.


*细节*:
>1.g++ 编译.c/.cpp 文件时, 生成的预编译, 编译, 汇编, 链接, 四个过程的文件.i, .s, .o, .exe 都是一样的.
   证明g++ 在遇到.c 语言的时候, 还是调用gcc 的接口, g++ 兼容c 语言.

>2.gcc 编译.cpp 文件时, 会发生分歧(下面描述的是分歧的细节):
   预编译: gcc 不能处理c++ 特有的预编译语句
   编译  : gcc 不能编译出c++ 库函数的汇编码
   汇编  : 将汇编码翻译成.o 文件, 这一步还是没啥区别的, 反正这是一个固定操作.
   链接  : gcc 不能链接g++ 的标准库, 也不能链接一些由c++ 编写的第三方库
          (就算连上了也会报错的)
   证明: gcc 不能翻译出c++ 语法!!

所以: 用g++ 兼容性强一些, 但是也要坚持写纯C 码, 然后弱c++ 语法还是很不错的





< x1.gcc 编译原理 >
[[ 你可以用一个hello world 程序, 
   跟着下面的1,2,3,4 个步骤去编译一个程序, 来查看真实的编译过程 ]]
(.i)1.预编译 -E  [处理宏定义和include, 去除注释, 不会对语法进行检查. ]

(.s)2.编译   -S  [检查语法, 生成汇编代码]

(.o)3.汇编   -c  [生成目标代码]


(  )4.链接   -o  [链接过程. 生成可执行代码. 
                 链接分为两种, 一种是静态链接, 另外一种是动态链接. ]
                *[使用静态链接的好处是, 依赖的动态链接库较少(静态编译), 
                  对动态链接库的版本不会很敏感, 具有较好的兼容性; 
                  缺点是生成的程序比较大.]
                *[使用动态链接的好处是, 生成的程序比较小, 占用较少的内存.]
                *[动态链接装载, 好处是: 一般程序运行初始化时, 就要找到并装载所有的'动态链接库'了, 
                  但是动态装载库, 可以在程序运行过程中, 有需要才装载这个库]
    链接的本质, 是ld 工具(GNU linker)的衔接, 调用. gcc 内置提供这样的简便调用ld 工具的功能.

只要'生成的.o 文件' 完整且正确 (不能缺少某个.o), 然后就可以进行最后一步->(链接).
最后一步<4.链接>, 链接可能找不到.o 文件or -l 编译选项库等, 可能会发生错误. 

生成可执行文件后:
  无论什么后缀都可以直接运行, linux 不认后缀, 直接认封装的, 
  链接之后就是可执行二进制封装了.





< x2.gcc/ld 链接原理 >
  gcc 实际上只是一个c 语言编译器, ld 才是真正的链接器.
  gcc 实际也是调用ld 的功能做链接, 这个概念让人混淆, 让人觉得gcc 是一个链接器, 实际这是错误的!


  ld 是一个将编译好的代码, 链接起来的工具.
  编译好的代码, 为什么需要链接??
  因为:
    实际编译好之后, 所有的函数, 都只是一根函数指针而已.
    函数体API 哪里去了??
    如果是'.a 静态库': 
      ld 链接器在链接的时候, 会将函数体整个拷贝一份出来, 插入到程序中.
      因此你可以看到, 使用ld 链接之后, .exe 文件远比.o 编译文件'大得多'.

      [ 微软的静态库与gcc 静态库有些不一样, 由于微软是商业系统, 对自家的静态库管理比较简单,
        微软提供: #program comment(lib,"") 来包含.a 静态库, 但是gcc 并没有相关的实现.]

      总体来说, 静态库需要直接用-l 'LDFLAGS链接选项'指明静态库的路径!!
      -lpthread 实际上, 就是链接静态库'libpthread.a', 在glibc 的实现中, 你可以找到:
        -lpthread = /lib/x86_64-linux-gnu/libpthread.so.0
        -lm       = /lib/x86_64-linux-gnu/libm.so.6
        (去掉lib 前缀和.so .a 后缀 + 版本号, remember??)


    如果是'.so 动态链接库':
      那么你需要在编译的时候, 指明编译选项-fPIC, 否则编译出来的函数, 不具备T 共享属性,
      外部程序无法访问到这样的函数, .so 链接库私有函数, 也有私有函数的作用, 这类似于OOP 面向对象的封装原理一样.

      再有, '.so 动态链接库'需要指明'链接选项' -shared, 否则不能达到节省内存的作用, 跟.a 静态链接库无异,
      每个使用它的进程, 都自己维护一套'.so 动态链接库'的代码块.
      ('.so 动态链接库'有1-5% 的性能损耗)

如果是'.so 动态装载库':
      那么你需要在'编码'的时候, '.so 动态链接库'的基础上, 再自定义'导出函数列表', 用来封装'私有函数/导出函数'.
      然后在'编码调用库函数'之前, 你先要描述'.so 动态装载库'的装载过程: dlopen()dlerror()dlsym()dlclose()
      ('.so 动态装载库'有1-5% 的性能损耗)





< x2.gcc 调试工具 >
*1.GCC 除错的首选工具是< GNU 除错器 >, 即gdb. 

*2.其他特殊用途的除错工具是 Valgrind, 用以发现内存漏失 (Memory leak). 

*3.GNU 测量器 (gprof) 可以得知程序中某些函式花费多少时间, 以及其呼叫频率; 
   此功能需要使用者在编译时选定测量〈profiling〉选项, 即编译选项-pg





< x3.gcc 编译选项 >
优化选项: 
  用GCC编译C/C++代码时, 它会试着用最少的时间完成编译并且编译后的代码易于调试. 
  易于调试意味着编译后的代码与源代码有同样的执行顺序, 编译后的代码没有经过优化. 
  
  有很多的选项可以告诉GCC, 在耗费更多编译时间和牺牲易调试性的基础上,
  产生更小更快的可执行文件. 
  这些选项中最典型的就是-O和-O2. 
  -O选项告诉gcc对源代码进行基本优化. 
  -O2选项告诉GCC产生尽可能小的和尽可能快的代码. 
  还有一些很特殊的选项可以通过man gcc察看. 

 -O, 对程序进行优化编译、链接.
     采用这个选项, 整个源代码会在编译、链接过程中进行优化处理, 
     这样产生的可执行文件的执行效率可以提高, 
     但是, 编译、链接的速度就相应地要慢一些. 
 -O2,比-O更好的优化编译、链接, 当然整个编译、链接过程会更慢. 





调试和剖析选项: 
  GCC支持数种调试剖析选项. 在这些选项中最常用的是-g和-pg.
  -g选项 告诉gcc产生能被GNU调试器（如gdb)使用的调试信息, 以便调试用户的程序.
         不能与-o 优化选项一同使用
  -pg选项 告诉gcc在用户的程序中加入额外的代码, 执行时, 
          产生gprof用的剖析信息以显示程序的耗时情况. 
          <但必须指定为GNU 源码才能使用-pg>


 -g, 产生符号调试工具(GNU的gdb)所必要的符号资讯, 
     要想对源代码进行调试, 我们就必须加入这个选项. 
-pg, 性能策略工具, 有了这个, 你就不需要自己做<太多不需要>的性能测试统计了, 
     gcc 帮你完成基础的性能测试. 




//***************************************************************


预编译, 编译, 汇编, 链接, 四个过程详细分析, 其它编译选项再说吧. 

//测试源码
#include<stdio.h>
int main(void){
  printf("hello world\n");
  return 0;
}



1.预编译过程
这个过程处理宏定义和include, 去除注释, 不会对语法进行检查. 
可以看到预编译后, 代码从6行扩展到了910行. 

gcc -E a.c -o a.i
cat a.c|wc -l
5
cat a.i|wc -l
910


2.编译过程
这个阶段, 检查语法, 生成汇编代码. 

gcc -S a.i -o a.s
cat a.s|wc-l
59


3.汇编过程
这个阶段, 生成目标代码. 此过程生成ELF格式的目标代码. 

gcc -c a.s -o a.o
file a.o
a.o:ELF64-bitLSBrelocatable,AMDx86-64,version1(SYSV),notstripped


4.链接过程
链接过程. 生成可执行代码. 链接分为两种, 一种是静态链接, 另外一种是动态链接. 
使用静态链接的好处是, 依赖的动态链接库较少, 
对动态链接库的版本不会很敏感, 具有较好的兼容性; 
缺点是生成的程序比较大. 
使用动态链接的好处是, 生成的程序比较小, 占用较少的内存. 

gcc a.o -o a

程序运行: 
./a
hello

